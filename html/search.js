window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "setu", "modulename": "setu", "kind": "module", "doc": "<h1 id=\"setu-a-comprehensive-pipeline-for-data-cleaning-filtering-and-deduplication\">Setu: A Comprehensive Pipeline for Data Cleaning, Filtering and Deduplication</h1>\n\n<p><img src=\"../setu.png\" alt=\"image\" width=\"700\" height=\"auto\"></p>\n\n<p>Setu is a comprehensive pipeline designed to clean, filter, and deduplicate diverse data sources including Web, PDF, and Speech data. Built on Apache Spark, Setu encompasses four key stages: document preparation, document cleaning and analysis, flagging and filtering, and deduplication.</p>\n\n<h1 id=\"table-of-contents\">Table of Contents</h1>\n\n<ol>\n<li><a href=\"#quickstart\">Quickstart</a></li>\n<li><a href=\"#overview\">Overview</a></li>\n<li><a href=\"#usage\">Usage</a></li>\n</ol>\n\n<h1 id=\"quickstart\">Quickstart</h1>\n\n<p>This documentation provides an overview of Setu and its workflow, enabling users to efficiently manage and process Web, PDF, and Speech data with <a href=\"https://spark.apache.org/downloads.html\">Apache Spark</a>.</p>\n\n<p>Note that users who want to run the pipeline on Windows systems are advised to use WSL (Windows Subsystem for Linux) for easier usage. This is due to the presence of dependencies and scripts that are only usable in a Linux environment.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<h3 id=\"install-python-onto-wsl\">Install Python onto WSL</h3>\n\n<ul>\n<li>Before installing make sure your Python Version is 3.10.X or above. For ease of installation we recommend using 3.10.X. Also make sure you have Miniconda installed as we will be using conda enviroments.</li>\n</ul>\n\n<h3 id=\"install-java-openjdk\">Install Java OpenJDK</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>sudo<span class=\"w\"> </span>update\nsudo<span class=\"w\"> </span>apt<span class=\"w\"> </span>install<span class=\"w\"> </span>openjdk-11-jdk\njava<span class=\"w\"> </span>--version\n</code></pre>\n</div>\n\n<h3 id=\"install-spark-for-hadoop-33\">Install Spark for Hadoop 3.3</h3>\n\n<p>Note : Ensure you do this the following in your home/user folder</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>wget<span class=\"w\"> </span>https://dlcdn.apache.org/spark/spark-3.5.1/spark-3.5.1-bin-hadoop3.tgz\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>mkdir<span class=\"w\"> </span>~/hadoop/spark-3.3.0\ntar<span class=\"w\"> </span>-xvzf<span class=\"w\"> </span>spark-3.3.0-bin-hadoop3.tgz<span class=\"w\"> </span>-C<span class=\"w\"> </span>~/hadoop/spark-3.3.0<span class=\"w\"> </span>--strip<span class=\"w\"> </span><span class=\"m\">1</span>\n</code></pre>\n</div>\n\n<h3 id=\"configuration\">Configuration</h3>\n\n<ul>\n<li>Edit your bashrc file and add the following lines</li>\n</ul>\n\n<pre><code>export SPARK_HOME= ~/hadoop/spark-3.3.0\nexport PATH=$SPARK_HOME/bin:$PATH\nsource ~/.bashrc\n</code></pre>\n\n<ul>\n<li>Copy the default spark config template and save it as config file.</li>\n</ul>\n\n<pre><code>cp $SPARK_HOME/conf/spark-defaults.conf.template $SPARK_HOME/conf/spark-defaults.conf\n</code></pre>\n\n<ul>\n<li>Edit the config file and mnetion spark host address.</li>\n</ul>\n\n<pre><code>nano $SPARK_HOME/conf/spark-defaults.conf\nspark.driver.host       localhost\n</code></pre>\n\n<ul>\n<li>Test your spark installation by running spark-shell.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>spark-shell\n</code></pre>\n</div>\n\n<h3 id=\"setu-environment-setup\">Setu Environment Setup</h3>\n\n<p>You can now directly create the conda environment from the environment.yaml file provided.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>conda<span class=\"w\"> </span>env<span class=\"w\"> </span>create<span class=\"w\"> </span>-f<span class=\"w\"> </span>environment.yml\n</code></pre>\n</div>\n\n<ul>\n<li>Refer the <a href=\"../packages.txt\">packages</a> text file for verification of libraries downloaded. Some libraries need to be downloaded utilizing pip.</li>\n</ul>\n\n<p>Make sure that Pyspark is working by running pyspark on the terminal</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pyspark\n</code></pre>\n</div>\n\n<h1 id=\"overview\">Overview</h1>\n\n<p>As part of the IndicLLMSuite : A Blueprint for Creating Pre-training and Fine-Tuning Datasets for Indian Languages we release Sangraha, a 251 billion tokens dataset summed up over 22 languages extracted from curated URLs, existing multilingual corpora, and large-scale translations.</p>\n\n<p>For data corpus we utilize <a href=\"https://github.com/AI4Bharat/webcorpus\">webcorpus</a> to crawl a large collection of web URLs curated across all 22 Indic languages. For PDF documents we download Book collections from <a href=\"archive.org\">Internet Archive</a> pertaining to Indic Languages. For ease of downloading PDF files, You can refer to <a href=\"https://github.com/AI4Bharat/sangraha-download-pipeline\">Sangraha Data Download</a>.</p>\n\n<h2 id=\"document-preparation\">Document Preparation</h2>\n\n<p>The first stage of Setu focuses on extracting text from a variety of sources to create text documents for further processing. For Web documents, Setu utilizes <a href=\"https://trafilatura.readthedocs.io/en/latest/\">trafilatura</a> (Barbaresi, 2021b) to extract text from HTML. Meanwhile, PDFs undergo a pipeline that generate OCR JSON outputs utilizing <a href=\"https://cloud.google.com/sdk/gcloud/reference/ml/vision/detect-text-pdf\">GCP Cloud Vision SDK</a>. Once these JSONs are generated, Setu leverages bounding box related information to filter out pages potentially afflicted with recognition issues and noise.</p>\n\n<h2 id=\"cleaning-and-analysis-stage\">Cleaning and Analysis Stage</h2>\n\n<p>In the cleaning and analysis stage, Setu focuses on reducing noise within individual documents. It employs a multi-model approach for language identification, leveraging outputs from three different Language Identification Libraries:</p>\n\n<ul>\n<li><a href=\"https://github.com/AI4Bharat/IndicLID\">IndicLID</a></li>\n<li><a href=\"https://huggingface.co/facebook/fasttext-language-identification\">NLLB</a></li>\n<li><a href=\"https://github.com/google/cld3\">Google cld3</a></li>\n</ul>\n\n<p>Various statistics such as character and word counts, NSFW word count, and n-gram repetition ratio are computed during analysis.</p>\n\n<h2 id=\"flagging-and-filtering-stage\">Flagging and Filtering Stage</h2>\n\n<p>During the flagging and filtering stage, Setu applies filters based on the computed statistics. Filters include line length filters, NSFW word filters, and repetition filters, aimed at removing noisy and toxic documents.</p>\n\n<h2 id=\"deduplication-stage\">Deduplication Stage</h2>\n\n<p>The deduplication stage of Setu performs fuzzy deduplication using MinHashLSH implemented in <a href=\"https://github.com/ChenghaoMou/text-dedup\">text-dedup</a>. This stage helps in identifying and eliminating duplicate documents, enhancing data cleanliness and efficiency.</p>\n\n<h1 id=\"usage\">Usage</h1>\n\n<p>For running the different stages in setu, You can refer to the <a href=\"../examples/commands.md\">commands</a> file and the also utilize the <a href=\"../examples/demo.ipynb\">demo</a> to understand the usage and output of the different stages. Make sure you configure the <code>$USER</code> and <code>--master</code> to point to your user folder and corresponding spark master URL. If you choose to store your datasets in a different location make sure you modify the different path arguments for the commands accordingly.</p>\n"}, {"fullname": "setu.analysis", "modulename": "setu.analysis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.analysis.split_with_delimiter_udf", "modulename": "setu.analysis", "qualname": "split_with_delimiter_udf", "kind": "function", "doc": "<p>split_with_delimiter Function that splits the given text based on the delimitter pattern provided</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text to be split.</li>\n<li><strong>delimiter_pattern (str, optional):</strong>  The delimitter regex pattern for splitting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of the lines split based on delimitter pattern.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">delimiter_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;[.?!\u0964|\u0965\u061f\u06d4](?:</span><span class=\"se\">\\\\</span><span class=\"s1\">n+)?&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.get_nsfw_word_dist_udf", "modulename": "setu.analysis", "qualname": "get_nsfw_word_dist_udf", "kind": "function", "doc": "<p>Returns NSFW word distances</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.non_li_chars_total_count_udf", "modulename": "setu.analysis", "qualname": "non_li_chars_total_count_udf", "kind": "function", "doc": "<p>Returns Non Latin-Indic word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.get_word_count_udf", "modulename": "setu.analysis", "qualname": "get_word_count_udf", "kind": "function", "doc": "<p>Returns line word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.get_char_count_udf", "modulename": "setu.analysis", "qualname": "get_char_count_udf", "kind": "function", "doc": "<p>Returns line character count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.get_bytes_udf", "modulename": "setu.analysis", "qualname": "get_bytes_udf", "kind": "function", "doc": "<p>Returns line bytes count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.get_nsfw_words_total_count_udf", "modulename": "setu.analysis", "qualname": "get_nsfw_words_total_count_udf", "kind": "function", "doc": "<p>Returns NSFW word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nsfw_words_dist</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.is_numbers_udf", "modulename": "setu.analysis", "qualname": "is_numbers_udf", "kind": "function", "doc": "<p>Returns True if line has only numbers</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.normalize_text_udf", "modulename": "setu.analysis", "qualname": "normalize_text_udf", "kind": "function", "doc": "<p>partial(func, <em>args, *</em>keywords) - new function with partial application\nof the given arguments and keywords.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">remove_nuktas</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nasals_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;do_nothing&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">do_normalize_chandras</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">do_normalize_vowel_ending</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage", "modulename": "setu.analysis", "qualname": "AnalysisStage", "kind": "class", "doc": "<p>SetuStage Base Class for the different stages in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.analysis.AnalysisStage.__init__", "modulename": "setu.analysis", "qualname": "AnalysisStage.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.analysis.AnalysisStage.wrap_funcs_to_udf", "modulename": "setu.analysis", "qualname": "AnalysisStage.wrap_funcs_to_udf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.add_cmdline_args", "modulename": "setu.analysis", "qualname": "AnalysisStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular stage</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.convert_to_line", "modulename": "setu.analysis", "qualname": "AnalysisStage.convert_to_line", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">text_col</span>, </span><span class=\"param\"><span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.line_stats_collection", "modulename": "setu.analysis", "qualname": "AnalysisStage.line_stats_collection", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">line_df</span>, </span><span class=\"param\"><span class=\"n\">text_col</span>, </span><span class=\"param\"><span class=\"n\">line_stats_output_path</span>, </span><span class=\"param\"><span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.aggregate_to_doc_stats", "modulename": "setu.analysis", "qualname": "AnalysisStage.aggregate_to_doc_stats", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">line_df</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">drop_repeated_line_dist</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.convert_to_doc", "modulename": "setu.analysis", "qualname": "AnalysisStage.convert_to_doc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">line_df</span>, </span><span class=\"param\"><span class=\"n\">text_col</span>, </span><span class=\"param\"><span class=\"n\">doc_id_col</span>, </span><span class=\"param\"><span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.collect_repetition_scores", "modulename": "setu.analysis", "qualname": "AnalysisStage.collect_repetition_scores", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">doc_stats_df</span>, </span><span class=\"param\"><span class=\"n\">doc_id_col</span>, </span><span class=\"param\"><span class=\"n\">text_col</span>, </span><span class=\"param\"><span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.run_stage_parallelized", "modulename": "setu.analysis", "qualname": "AnalysisStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">line_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.run_data_parallelized", "modulename": "setu.analysis", "qualname": "AnalysisStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">line_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.run_spark", "modulename": "setu.analysis", "qualname": "AnalysisStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_analysis_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">line_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.run", "modulename": "setu.analysis", "qualname": "AnalysisStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.analysis.AnalysisStage.run_normal", "modulename": "setu.analysis", "qualname": "AnalysisStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_analysis_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">line_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.base", "modulename": "setu.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.base.SetuStage", "modulename": "setu.base", "qualname": "SetuStage", "kind": "class", "doc": "<p>SetuStage Base Class for the different stages in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "setu.base.SetuStage.config", "modulename": "setu.base", "qualname": "SetuStage.config", "kind": "variable", "doc": "<p>Configuration Namespace object for the particular stage.</p>\n"}, {"fullname": "setu.base.SetuStage.name", "modulename": "setu.base", "qualname": "SetuStage.name", "kind": "variable", "doc": "<p>Name of the particular stage.</p>\n"}, {"fullname": "setu.base.SetuStage.df_total_rows", "modulename": "setu.base", "qualname": "SetuStage.df_total_rows", "kind": "variable", "doc": "<p>Total number of rows in the given Dataframe Object.</p>\n"}, {"fullname": "setu.base.SetuStage.add_cmdline_args", "modulename": "setu.base", "qualname": "SetuStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular stage</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.get_stage_name", "modulename": "setu.base", "qualname": "SetuStage.get_stage_name", "kind": "function", "doc": "<p>get_stage_name Method to fetch the particular stage name</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cls (ABC):</strong>  The self cls of which the name should be returned</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Name of the stage</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ABC</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.salting", "modulename": "setu.base", "qualname": "SetuStage.salting", "kind": "function", "doc": "<p>salting Method which performs salting on the particular dataframe object to handle data skewness.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The dataframe object that is processed by the stage.</li>\n<li><strong>n_splits (int):</strong>  Number of splits for salting</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: Returns the dataframe object after performing salting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">n_splits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.set_split_count_and_salt", "modulename": "setu.base", "qualname": "SetuStage.set_split_count_and_salt", "kind": "function", "doc": "<p>set_split_count_and_salt Method to calculate the number of splits and salting given the dataframe and number of documents per partition.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The dataframe object that is processed by the stage.</li>\n<li><strong>docs_per_partition (int):</strong>  Number of documents that each spark partition should handle.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: Returns the dataframe object after performing salting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.run_stage_parallelized", "modulename": "setu.base", "qualname": "SetuStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.run_data_parallelized", "modulename": "setu.base", "qualname": "SetuStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.run_spark", "modulename": "setu.base", "qualname": "SetuStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parallel_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;stage&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"ne\">Exception</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.run_normal", "modulename": "setu.base", "qualname": "SetuStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuStage.run", "modulename": "setu.base", "qualname": "SetuStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parallel_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;stage&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuComponent", "modulename": "setu.base", "qualname": "SetuComponent", "kind": "class", "doc": "<p>SetuComponent Base Class for the different components in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "setu.base.SetuComponent.config", "modulename": "setu.base", "qualname": "SetuComponent.config", "kind": "variable", "doc": "<p>Configuration Namespace object for the particular component.</p>\n"}, {"fullname": "setu.base.SetuComponent.name", "modulename": "setu.base", "qualname": "SetuComponent.name", "kind": "variable", "doc": "<p>Name of the particular component.</p>\n"}, {"fullname": "setu.base.SetuComponent.add_cmdline_args", "modulename": "setu.base", "qualname": "SetuComponent.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular component</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuComponent.get_component_name", "modulename": "setu.base", "qualname": "SetuComponent.get_component_name", "kind": "function", "doc": "<p>get_component_name Method to fetch the particular component name</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cls (ABC):</strong>  The self cls of which the name should be returned</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Name of the component</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ABC</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuComponent.get_stage_mapping", "modulename": "setu.base", "qualname": "SetuComponent.get_stage_mapping", "kind": "function", "doc": "<p>get_stage_mapping Method the provides the a dictionary mapping of the stage names as keys and their corresponding stage objects as values.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the different stage names and objects as key/value pairs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuComponent.run_stage", "modulename": "setu.base", "qualname": "SetuComponent.run_stage", "kind": "function", "doc": "<p>run_stage Method the triggers the execution of a particular stage/omponent if the stage/component name is provided.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.base.SetuComponent.run", "modulename": "setu.base", "qualname": "SetuComponent.run", "kind": "function", "doc": "<p>run Method that triggers the execution of the component.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis", "modulename": "setu.clean_analysis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.clean_analysis.find_code_spans_udf", "modulename": "setu.clean_analysis", "qualname": "find_code_spans_udf", "kind": "function", "doc": "<p>find_code_spans_spark Returns a Pyspark Row that contains the code content in the given text</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc_id (str):</strong>  The document ID</li>\n<li><strong>text (str):</strong>  The text containing the code spans/lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Row: A Pyspark Row object containing the code spans and if present.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doc_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Row</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.remove_code_udf", "modulename": "setu.clean_analysis", "qualname": "remove_code_udf", "kind": "function", "doc": "<p>remove_code Functions that removes the provided code spans from the text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text string.</li>\n<li><strong>code_spans (list):</strong>  list of code spans that need to be removed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Returns the text string after removing code spans.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">code_spans</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.get_symbol_ratio_udf", "modulename": "setu.clean_analysis", "qualname": "get_symbol_ratio_udf", "kind": "function", "doc": "<p>partial(func, <em>args, *</em>keywords) - new function with partial application\nof the given arguments and keywords.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">char_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.is_num_or_punc_only_udf", "modulename": "setu.clean_analysis", "qualname": "is_num_or_punc_only_udf", "kind": "function", "doc": "<p>is_num_or_punc_only Function that checks if a line is either numbers or punctuation only</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>s (str):</strong>  Line to be processed</li>\n<li><strong>threshold (float, optional):</strong>  Threshold value for checking number of numeric/punctuation characters in the line. Defaults to 0.4.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: Boolean Value that indicates if the string had numeric or punctuation only as majority content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.4</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.is_terminal_valid_udf", "modulename": "setu.clean_analysis", "qualname": "is_terminal_valid_udf", "kind": "function", "doc": "<p>is_terminal_valid Check if the line terminal is a valid value.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text to be checked.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: Boolean value indicating if the line has a valid terminal value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.get_word_count_udf", "modulename": "setu.clean_analysis", "qualname": "get_word_count_udf", "kind": "function", "doc": "<p>Returns line word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.get_char_count_udf", "modulename": "setu.clean_analysis", "qualname": "get_char_count_udf", "kind": "function", "doc": "<p>Returns line character count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.get_bytes_udf", "modulename": "setu.clean_analysis", "qualname": "get_bytes_udf", "kind": "function", "doc": "<p>Returns line bytes count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage", "kind": "class", "doc": "<p>DocCleanStage The SetuStage Class extension for document cleaning.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>SetuStage (class):</strong>  SetuStage class to inherit</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.clean_analysis.DocCleanStage.__init__", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.__init__", "kind": "function", "doc": "<p>__init__ Initialize the ExtractTextStage with the configuration provided</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  Configuration Namespace object for the particular language and data source.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.clean_analysis.DocCleanStage.add_cmdline_args", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Method that adds the ExtractTextStage arguments to the main setu parser.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  Main Setu parser</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ArgumentParser: Modified Setu parser object with stage arguments</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.doc_clean_stage", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.doc_clean_stage", "kind": "function", "doc": "<p>doc_clean_stage Method that performs document cleaning on the given dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The input dataframe.</li>\n<li><strong>text_col (str):</strong>  The column name for the text content.</li>\n<li><strong>doc_id_col (str):</strong>  The column name for the document identifier.</li>\n<li><strong>use_symbol_filter (bool):</strong>  Whether to use symbol filters.</li>\n<li><strong>save_symbol_heavy_docs (bool):</strong>  Whether to save symbol heavy documents.</li>\n<li><strong>symbol_filter_output_path (str):</strong>  The output path to save the filtered output.</li>\n<li><strong>verbose (bool):</strong>  Whether to display cleaning progress.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">use_symbol_filter</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">save_symbol_heavy_docs</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_filter_output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run_preprocessing", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run_preprocessing", "kind": "function", "doc": "<p>run_preprocessing Method to run preprocessing on the given dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The input dataframe</li>\n<li><strong>additional_cols_to_use (list):</strong>  Additional columns to use while preprocessing</li>\n<li><strong>doc_id_col (str):</strong>  The column name for the document identifier.</li>\n<li><strong>text_col (str):</strong>  The column name for the text content.</li>\n<li><strong>docs_per_partition (int):</strong>  The number of documents per spark partition</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run_stage_parallelized", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">use_symbol_filter</span>,</span><span class=\"param\">\t<span class=\"n\">save_symbol_heavy_docs</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_filter_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">cleaned_doc_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run_data_parallelized", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">use_symbol_filter</span>,</span><span class=\"param\">\t<span class=\"n\">save_symbol_heavy_docs</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_filter_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">cleaned_doc_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run_spark", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">doc_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_doc_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">use_symbol_filter</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">save_symbol_heavy_docs</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_filter_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">cleaned_doc_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.DocCleanStage.run_normal", "modulename": "setu.clean_analysis", "qualname": "DocCleanStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">doc_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_doc_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">use_symbol_filter</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">doc_clean_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">save_symbol_heavy_docs</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_filter_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">cleaned_doc_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent", "kind": "class", "doc": "<p>SetuComponent Base Class for the different components in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuComponent"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.__init__", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span></span>)</span>"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.doc_clean_stage", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.doc_clean_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.lid_stage", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.lid_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.analysis_stage", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.analysis_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.stages", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.stages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.add_cmdline_args", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular component</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">parser</span>, </span><span class=\"param\"><span class=\"n\">for_full_pipeline</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.get_stage_mapping", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.get_stage_mapping", "kind": "function", "doc": "<p>get_stage_mapping Method the provides the a dictionary mapping of the stage names as keys and their corresponding stage objects as values.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the different stage names and objects as key/value pairs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.run_stage", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.run_stage", "kind": "function", "doc": "<p>run_stage Method the triggers the execution of a particular stage/omponent if the stage/component name is provided.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.clean_analysis.CleanAnalysisComponent.run", "modulename": "setu.clean_analysis", "qualname": "CleanAnalysisComponent.run", "kind": "function", "doc": "<p>run Method that triggers the execution of the component.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.constants", "modulename": "setu.constants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.constants.Constants", "modulename": "setu.constants", "qualname": "Constants", "kind": "class", "doc": "<p>The Constants Class contains different types of variables and lists such languages, nsfw words, stop words, punctuations, non indic latin patterns, junk patterns, etc.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filter_data_root</strong>:  Path to the data file containing various filters</li>\n</ul>\n"}, {"fullname": "setu.constants.Constants.__init__", "modulename": "setu.constants", "qualname": "Constants.__init__", "kind": "function", "doc": "<p>__init__ Initializes the Constants class </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>filter_data_root (str):</strong>  Data path for the available filters</li>\n<li><strong>junk_partial_glob (str, optional):</strong>  Data path for the junk partial texts. Defaults to \"junk/partial/*.txt\".</li>\n<li><strong>junk_complete_glob (str, optional):</strong>  Data path for the junk complete texts. Defaults to \"junk/complete/*.txt\".</li>\n<li><strong>stopwords_glob (str, optional):</strong>  Data path for the stopword text files. Defaults to \"stopwords/*.txt\".</li>\n<li><strong>nsfw_words_glob (str, optional):</strong>  Data path for the NSFW text files. Defaults to \"nsfw/*.txt\".</li>\n<li><strong>langs (list, optional):</strong>  Language list. Defaults to [ \"assamese\", \"bengali\", \"bodo\", \"dogri\", \"english\", \"gujarati\", \"hindi\", \"kannada\", \"kashmiri\", \"konkani\", \"maithili\", \"malayalam\", \"marathi\", \"manipuri\", \"nepali\", \"oriya\", \"punjabi\", \"sanskrit\", \"santhali\", \"sindhi\", \"tamil\", \"telugu\", \"urdu\", \"other\", ].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filter_data_root</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">junk_partial_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;junk/partial/*.txt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">junk_complete_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;junk/complete/*.txt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">stopwords_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;stopwords/*.txt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_words_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nsfw/*.txt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">langs</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;assamese&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bengali&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bodo&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dogri&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;english&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;gujarati&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;hindi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;kannada&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;kashmiri&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;konkani&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;maithili&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;malayalam&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;marathi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;manipuri&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;nepali&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;oriya&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;punjabi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;sanskrit&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;santhali&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;sindhi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;tamil&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;telugu&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;urdu&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;other&#39;</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "setu.constants.Constants.filter_data_root", "modulename": "setu.constants", "qualname": "Constants.filter_data_root", "kind": "variable", "doc": "<p>The filter data root path.</p>\n"}, {"fullname": "setu.constants.Constants.junk_partial_glob", "modulename": "setu.constants", "qualname": "Constants.junk_partial_glob", "kind": "variable", "doc": "<p>The junk partial texts path.</p>\n"}, {"fullname": "setu.constants.Constants.junk_complete_glob", "modulename": "setu.constants", "qualname": "Constants.junk_complete_glob", "kind": "variable", "doc": "<p>The junk complete texts path.</p>\n"}, {"fullname": "setu.constants.Constants.stopwords_glob", "modulename": "setu.constants", "qualname": "Constants.stopwords_glob", "kind": "variable", "doc": "<p>The stopwords texts path.</p>\n"}, {"fullname": "setu.constants.Constants.nsfw_words_glob", "modulename": "setu.constants", "qualname": "Constants.nsfw_words_glob", "kind": "variable", "doc": "<p>The nsfw texts path.</p>\n"}, {"fullname": "setu.constants.Constants.FILTER_WORDS", "modulename": "setu.constants", "qualname": "Constants.FILTER_WORDS", "kind": "variable", "doc": "<p>Filter Words mapping for each language</p>\n"}, {"fullname": "setu.constants.Constants.non_indic_non_latin_re_pattern", "modulename": "setu.constants", "qualname": "Constants.non_indic_non_latin_re_pattern", "kind": "variable", "doc": "<p>Non Latin Indic Patterns</p>\n"}, {"fullname": "setu.constants.Constants.TERMINAL_PUNCTUATIONS", "modulename": "setu.constants", "qualname": "Constants.TERMINAL_PUNCTUATIONS", "kind": "variable", "doc": "<p>List of terminal punctuations</p>\n"}, {"fullname": "setu.constants.Constants.TERMINAL_PUNCTUATIONS_EXCEPTION", "modulename": "setu.constants", "qualname": "Constants.TERMINAL_PUNCTUATIONS_EXCEPTION", "kind": "variable", "doc": "<p>List of terminal punctuation exceptions</p>\n"}, {"fullname": "setu.constants.Constants.MIN_WORDS", "modulename": "setu.constants", "qualname": "Constants.MIN_WORDS", "kind": "variable", "doc": "<p>Minimum number of words to be present</p>\n"}, {"fullname": "setu.constants.Constants.MAX_WORDS", "modulename": "setu.constants", "qualname": "Constants.MAX_WORDS", "kind": "variable", "doc": "<p>Maximum number of words to be present</p>\n"}, {"fullname": "setu.constants.Constants.MIN_STOP_WORDS", "modulename": "setu.constants", "qualname": "Constants.MIN_STOP_WORDS", "kind": "variable", "doc": "<p>Minimum number of stopwords to be present</p>\n"}, {"fullname": "setu.constants.Constants.CPU_COUNT", "modulename": "setu.constants", "qualname": "Constants.CPU_COUNT", "kind": "variable", "doc": "<p>CPU Count for multiprocessing</p>\n"}, {"fullname": "setu.constants.Constants.load_junk_partial", "modulename": "setu.constants", "qualname": "Constants.load_junk_partial", "kind": "function", "doc": "<p>load_junk_partial Loads the Junk Partial Texts</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>junk_partial_glob (str):</strong>  Path to Junk Partial text files.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">junk_partial_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.Constants.load_junk_complete", "modulename": "setu.constants", "qualname": "Constants.load_junk_complete", "kind": "function", "doc": "<p>load_junk_complete Loads the Junk Complete Texts</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>junk_complete_glob (str):</strong>  Path to Junk Complete text files.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">junk_complete_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.Constants.load_stop_words", "modulename": "setu.constants", "qualname": "Constants.load_stop_words", "kind": "function", "doc": "<p>load_stop_words Loads the list of stopwords</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>stopwords_glob (str):</strong>  Path to Stopword text files.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">stopwords_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.Constants.load_nsfw_words", "modulename": "setu.constants", "qualname": "Constants.load_nsfw_words", "kind": "function", "doc": "<p>load_nsfw_words Loads the list of nsfw words</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>msfw_words_glob (str):</strong>  Path to nsfw word text files.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nsfw_words_glob</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.create_kwpr", "modulename": "setu.constants", "qualname": "create_kwpr", "kind": "function", "doc": "<p>create_kwpr Creates a flashtext Keywordprocessor given a list of keywords</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>keywords (dict):</strong>  Dictionary containing all the keywords</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws exception if not a dict or list object</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>KeywordProcessor: KeywordProcessor loaded with required keywords</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">keywords</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">flashtext</span><span class=\"o\">.</span><span class=\"n\">keyword</span><span class=\"o\">.</span><span class=\"n\">KeywordProcessor</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.init_kwprs", "modulename": "setu.constants", "qualname": "init_kwprs", "kind": "function", "doc": "<p>init_kwprs Initialize the keword processors given the various constants.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>constants (Constants):</strong>  Constants class object</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the keyword processors</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">constants</span><span class=\"p\">:</span> <span class=\"n\">setu</span><span class=\"o\">.</span><span class=\"n\">constants</span><span class=\"o\">.</span><span class=\"n\">Constants</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.constants.CONSTANTS", "modulename": "setu.constants", "qualname": "CONSTANTS", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;setu.constants.Constants object&gt;"}, {"fullname": "setu.filters", "modulename": "setu.filters", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.filters.get_symbol_ratio", "modulename": "setu.filters", "qualname": "get_symbol_ratio", "kind": "function", "doc": "<p>get_symbol_ratio Returns the ratio of invalid characters, the number of invalid characters and the invalid characters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>s (str):</strong>  Line that needs to be processed.</li>\n<li><strong>char_count (int):</strong>  Number of characters in the the line.</li>\n<li><strong>for_spark (bool, optional):</strong>  If computation required as part of spark pipeline. Defaults to True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">char_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_num_or_punc_only", "modulename": "setu.filters", "qualname": "is_num_or_punc_only", "kind": "function", "doc": "<p>is_num_or_punc_only Function that checks if a line is either numbers or punctuation only</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>s (str):</strong>  Line to be processed</li>\n<li><strong>threshold (float, optional):</strong>  Threshold value for checking number of numeric/punctuation characters in the line. Defaults to 0.4.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: Boolean Value that indicates if the string had numeric or punctuation only as majority content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.4</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.patterns", "modulename": "setu.filters", "qualname": "patterns", "kind": "variable", "doc": "<p>The various patterns to identify if the text is HTML, JS or CSS content.</p>\n", "default_value": "[(re.compile(&#x27;&lt;[^&gt;]+?&gt;.+?&lt;/[^&gt;]+?&gt;&#x27;), &#x27;HTML&#x27;), (re.compile(&#x27;(?s)function\\\\s*?\\\\(.*?\\\\)\\\\s*?\\\\{.*?\\\\}&#x27;, re.DOTALL), &#x27;JavaScript&#x27;), (re.compile(&#x27;(?s)\\\\..*?\\\\{.*?\\\\}&#x27;, re.DOTALL), &#x27;CSS&#x27;)]"}, {"fullname": "setu.filters.find_code_spans_spark", "modulename": "setu.filters", "qualname": "find_code_spans_spark", "kind": "function", "doc": "<p>find_code_spans_spark Returns a Pyspark Row that contains the code content in the given text</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc_id (str):</strong>  The document ID</li>\n<li><strong>text (str):</strong>  The text containing the code spans/lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Row: A Pyspark Row object containing the code spans and if present.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doc_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Row</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.find_code_spans", "modulename": "setu.filters", "qualname": "find_code_spans", "kind": "function", "doc": "<p>find_code_spans Returns a list that contains the code content in the given text</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc_id (str):</strong>  The document ID</li>\n<li><strong>text (str):</strong>  The text containing the code spans/lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list|None: List of code spans in the given text.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doc_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_terminal_valid", "modulename": "setu.filters", "qualname": "is_terminal_valid", "kind": "function", "doc": "<p>is_terminal_valid Check if the line terminal is a valid value.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text to be checked.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: Boolean value indicating if the line has a valid terminal value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.remove_non_terminal_punc_span", "modulename": "setu.filters", "qualname": "remove_non_terminal_punc_span", "kind": "function", "doc": "<p>remove_non_terminal_punc_span Function that removes non terminal punctuation spans.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>chunk (str):</strong>  The text chunk to be processed.</li>\n<li><strong>is_term_valid (bool):</strong>  Boolean value if terminal is valid.</li>\n<li><strong>chunk_len_threshold (float):</strong>  Value representing the minimum chunk length</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str|None: Return the text chunk after removing non terminal punctuation spans.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">chunk</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">is_term_valid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_len_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.split_at_terminal_punc", "modulename": "setu.filters", "qualname": "split_at_terminal_punc", "kind": "function", "doc": "<p>split_at_terminal_punc Split text at the terminal punctuation for the corresponding language</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text string.</li>\n<li><strong>lang (str):</strong>  Language for the text.</li>\n<li><strong>lang_code (str):</strong>  Language ISO Code.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Returns the sentence_split for the text and language code.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang_code</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.split_with_delimiter", "modulename": "setu.filters", "qualname": "split_with_delimiter", "kind": "function", "doc": "<p>split_with_delimiter Function that splits the given text based on the delimitter pattern provided</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text to be split.</li>\n<li><strong>delimiter_pattern (str, optional):</strong>  The delimitter regex pattern for splitting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of the lines split based on delimitter pattern.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">delimiter_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;[.?!\u0964|\u0965\u061f\u06d4](?:</span><span class=\"se\">\\\\</span><span class=\"s1\">n+)?&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.has_code", "modulename": "setu.filters", "qualname": "has_code", "kind": "function", "doc": "<p>has_code Check if the code_spans value is a list</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>code_spans (list):</strong>  The code_spans variable</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: Boolean Value representing if the code_spans is a non-null object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">code_spans</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.remove_code", "modulename": "setu.filters", "qualname": "remove_code", "kind": "function", "doc": "<p>remove_code Functions that removes the provided code spans from the text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text string.</li>\n<li><strong>code_spans (list):</strong>  list of code spans that need to be removed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Returns the text string after removing code spans.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">code_spans</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.terminal_punc_filter", "modulename": "setu.filters", "qualname": "terminal_punc_filter", "kind": "function", "doc": "<p>terminal_punc_filter Function that filters out punctuations from the text provided.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text string.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.normalize_text", "modulename": "setu.filters", "qualname": "normalize_text", "kind": "function", "doc": "<p>normalize_text Function that normalizes the given text utilizing the IndicNormalizerFactory.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  The text string.</li>\n<li><strong>lang (str):</strong>  The text language.</li>\n<li><strong>remove_nuktas (bool, optional):</strong>  Whether to remove nuktas. Defaults to False.</li>\n<li><strong>nasals_mode (str, optional):</strong>  Not Defined. Defaults to 'do_nothing'.</li>\n<li><strong>do_normalize_chandras (bool, optional):</strong>  Whether to normalize chandras. Defaults to False.</li>\n<li><strong>do_normalize_vowel_ending (bool, optional):</strong>  Whether to normalize vowel endings. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Return Normalize Function call on the text given the language value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">remove_nuktas</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nasals_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;do_nothing&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">do_normalize_chandras</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">do_normalize_vowel_ending</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_num_lines", "modulename": "setu.filters", "qualname": "get_num_lines", "kind": "function", "doc": "<p>get_num_lines Returns the number of lines in the line list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line_list (list):</strong>  List of lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the number of lines in the line list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_line_length_stats", "modulename": "setu.filters", "qualname": "get_line_length_stats", "kind": "function", "doc": "<p>get_line_length_stats Function that generates a dictionary of line length statistics.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line_lengths (list):</strong>  List of all the line lengths.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the line length statistics.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line_lengths</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_aggregate_stats", "modulename": "setu.filters", "qualname": "get_aggregate_stats", "kind": "function", "doc": "<p>get_aggregate_stats Function that aggregates all the line statistics.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line_stats_list (list):</strong>  List of all the line stats.</li>\n<li><strong>nsfw_count_key (str):</strong>  Key for NSFW Count</li>\n<li><strong>words_count_key (str):</strong>  Key for Word Count</li>\n<li><strong>char_count_key (str):</strong>  Key for Character Count</li>\n<li><strong>non_li_key (str):</strong>  Key for Non Latin-Indic Count</li>\n<li><strong>bytes_key (str):</strong>  Key for bytes Count</li>\n<li><strong>symbol_number_count_key (str):</strong>  Key for Symbol/Number Count</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing all the aggregate statistics.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">line_stats_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">words_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">char_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">non_li_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">bytes_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_number_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.restructure_nsfw_dists", "modulename": "setu.filters", "qualname": "restructure_nsfw_dists", "kind": "function", "doc": "<p>restructure_nsfw_dists Function to restructure the NSFW Dictionary.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (list):</strong>  List containing language NSFW dictionaries</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Restructured NSFW Dictionary</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_nsfw_heavy", "modulename": "setu.filters", "qualname": "is_nsfw_heavy", "kind": "function", "doc": "<p>Returns Boolean Value that indicates if the provided values corresponde to nsfw heavy ratio.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nsfw_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">word_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_symbol_number_heavy", "modulename": "setu.filters", "qualname": "is_symbol_number_heavy", "kind": "function", "doc": "<p>Returns Boolean Value that indicates if the provided values corresponde to symbol heavy ratio.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">symbol_number_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">char_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_non_li_heavy", "modulename": "setu.filters", "qualname": "is_non_li_heavy", "kind": "function", "doc": "<p>Returns Boolean Value that indicates if the provided values corresponding to non latin indic heavy ratio.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">text_len</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_repeated_line_dist", "modulename": "setu.filters", "qualname": "get_repeated_line_dist", "kind": "function", "doc": "<p>Returns a dict (str,int) containing repeated line and there distances</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line_stats</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">text_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_char_ngram_repetition", "modulename": "setu.filters", "qualname": "get_char_ngram_repetition", "kind": "function", "doc": "<p>Returns a dict contain char ngram repetition scores</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">ngrams_arr</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_word_ngram_repetition", "modulename": "setu.filters", "qualname": "get_word_ngram_repetition", "kind": "function", "doc": "<p>Returns a dict contain word ngram repetition scores</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang_code</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">ngrams_arr</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.has_repetition", "modulename": "setu.filters", "qualname": "has_repetition", "kind": "function", "doc": "<p>Checks if the scores correspond to repetitive n-grams or not.\nUse same function for word and character n-gram repetition.\nJust the repetition scores and thresholds will change.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">repetition_scores</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">repetition_thresholds</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.extract_document_metadata", "modulename": "setu.filters", "qualname": "extract_document_metadata", "kind": "function", "doc": "<p>Returns extracted document metadata</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">doc_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_stats_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang_code</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">text_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">words_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">char_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">non_li_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">bytes_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_number_count_key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">word_ngrams</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>,</span><span class=\"param\">\t<span class=\"n\">char_ngrams</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span>,</span><span class=\"param\">\t<span class=\"n\">url</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.perform_doc_flagging", "modulename": "setu.filters", "qualname": "perform_doc_flagging", "kind": "function", "doc": "<p>Returns document flags with corresponding boolean values</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">doc</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">min_line_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">min_mean_line_len</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">symbol_number_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">non_li_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">word_ngram_cum_thresholds</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;6&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;7&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;8&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;9&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">char_ngram_cum_thresholds</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;5&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;6&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;7&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"s1\">&#39;8&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1.0</span><span class=\"p\">}</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_stop_word_dist", "modulename": "setu.filters", "qualname": "get_stop_word_dist", "kind": "function", "doc": "<p>Returns stop word distances</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_nsfw_words_pos", "modulename": "setu.filters", "qualname": "get_nsfw_words_pos", "kind": "function", "doc": "<p>Returns NSFW word positions in line</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_nsfw_word_dist", "modulename": "setu.filters", "qualname": "get_nsfw_word_dist", "kind": "function", "doc": "<p>Returns NSFW word distances</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.non_li_chars_total_count", "modulename": "setu.filters", "qualname": "non_li_chars_total_count", "kind": "function", "doc": "<p>Returns Non Latin-Indic word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_word_count", "modulename": "setu.filters", "qualname": "get_word_count", "kind": "function", "doc": "<p>Returns line word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_char_count", "modulename": "setu.filters", "qualname": "get_char_count", "kind": "function", "doc": "<p>Returns line character count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_bytes", "modulename": "setu.filters", "qualname": "get_bytes", "kind": "function", "doc": "<p>Returns line bytes count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_nsfw_words_total_count", "modulename": "setu.filters", "qualname": "get_nsfw_words_total_count", "kind": "function", "doc": "<p>Returns NSFW word count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nsfw_words_dist</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.is_numbers", "modulename": "setu.filters", "qualname": "is_numbers", "kind": "function", "doc": "<p>Returns True if line has only numbers</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">line</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.get_stopword_total_count", "modulename": "setu.filters", "qualname": "get_stopword_total_count", "kind": "function", "doc": "<p>Returns stopword total count</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">stop_word_dist</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.filters.extract_line_metadata", "modulename": "setu.filters", "qualname": "extract_line_metadata", "kind": "function", "doc": "<p>Returns line associated stats and metadata</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">doc_id</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang_code</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">url</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal", "modulename": "setu.flagging_and_removal", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage", "kind": "class", "doc": "<p>SetuStage Base Class for the different stages in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.__init__", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.wrap_funcs_with_udf", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.wrap_funcs_with_udf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.add_cmdline_args", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular stage</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.run_stage_parallelized", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_df</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">save_nsfw_data</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.run_data_parallelized", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_df</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">save_nsfw_data</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.run_spark", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_doc_stats_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">save_nsfw_data</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.run", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlaggingAndFilteringStage.run_normal", "modulename": "setu.flagging_and_removal", "qualname": "FlaggingAndFilteringStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_doc_stats_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">fnf_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">save_nsfw_data</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_doc_stats_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage", "kind": "class", "doc": "<p>SetuStage Base Class for the different stages in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.__init__", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.add_cmdline_args", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular stage</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.run_stage_parallelized", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_df</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_docs_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.run_data_parallelized", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_df</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_docs_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.run_spark", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_out_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_join_col</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_docs_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.run", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.DocumentRemovalStage.run_normal", "modulename": "setu.flagging_and_removal", "qualname": "DocumentRemovalStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">analysis_out_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_stats_path</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_join_col</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">doc_removal_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">filtered_docs_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent", "kind": "class", "doc": "<p>SetuComponent Base Class for the different components in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuComponent"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.__init__", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.ff_stage", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.ff_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.doc_removal_stage", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.doc_removal_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.stages", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.stages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.add_cmdline_args", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular component</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">parser</span>, </span><span class=\"param\"><span class=\"n\">for_full_pipeline</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.get_stage_mapping", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.get_stage_mapping", "kind": "function", "doc": "<p>get_stage_mapping Method the provides the a dictionary mapping of the stage names as keys and their corresponding stage objects as values.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the different stage names and objects as key/value pairs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.run_stage", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.run_stage", "kind": "function", "doc": "<p>run_stage Method the triggers the execution of a particular stage/omponent if the stage/component name is provided.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.flagging_and_removal.FlagAndRemoveComponent.run", "modulename": "setu.flagging_and_removal", "qualname": "FlagAndRemoveComponent.run", "kind": "function", "doc": "<p>run Method that triggers the execution of the component.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid", "modulename": "setu.lid", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicBERT_Data", "modulename": "setu.lid", "qualname": "IndicBERT_Data", "kind": "class", "doc": "<p>An abstract class representing a <code>Dataset</code>.</p>\n\n<p>All datasets that represent a map from keys to data samples should subclass\nit. All subclasses should overwrite <code>__getitem__()</code>, supporting fetching a\ndata sample for a given key. Subclasses could also optionally overwrite\n<code>__len__()</code>, which is expected to return the size of the dataset by many\n<code>~torch.utils.data.Sampler</code> implementations and the default options\nof <code>~torch.utils.data.DataLoader</code>. Subclasses could also\noptionally implement <code>__getitems__()</code>, for speedup batched samples\nloading. This method accepts list of indices of samples of batch and returns\nlist of samples.</p>\n\n<div class=\"pdoc-alert pdoc-alert-note\">\n\n<p><code>~torch.utils.data.DataLoader</code> by default constructs an index\nsampler that yields integral indices.  To make it work with a map-style\ndataset with non-integral indices/keys, a custom sampler must be provided.</p>\n\n</div>\n", "bases": "typing.Generic[+T_co]"}, {"fullname": "setu.lid.IndicBERT_Data.__init__", "modulename": "setu.lid", "qualname": "IndicBERT_Data.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">indices</span>, </span><span class=\"param\"><span class=\"n\">X</span></span>)</span>"}, {"fullname": "setu.lid.IndicBERT_Data.size", "modulename": "setu.lid", "qualname": "IndicBERT_Data.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicBERT_Data.x", "modulename": "setu.lid", "qualname": "IndicBERT_Data.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicBERT_Data.i", "modulename": "setu.lid", "qualname": "IndicBERT_Data.i", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID", "modulename": "setu.lid", "qualname": "IndicLID", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.__init__", "modulename": "setu.lid", "qualname": "IndicLID.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indiclid_ftn_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;models/indiclid-ftn/model_baseline_roman.bin&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_ftr_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;models/indiclid-ftr/model_baseline_roman.bin&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_bert_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;models/indiclid-bert/basline_nn_simple.pt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">input_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">roman_lid_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "setu.lid.IndicLID.device", "modulename": "setu.lid", "qualname": "IndicLID.device", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.indiclid_ftn_path", "modulename": "setu.lid", "qualname": "IndicLID.indiclid_ftn_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.indiclid_ftr_path", "modulename": "setu.lid", "qualname": "IndicLID.indiclid_ftr_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.indiclid_bert_path", "modulename": "setu.lid", "qualname": "IndicLID.indiclid_bert_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_FTN", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_FTN", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_FTR", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_FTR", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_BERT", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_BERT", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_BERT_tokenizer", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_BERT_tokenizer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.input_threshold", "modulename": "setu.lid", "qualname": "IndicLID.input_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.model_threshold", "modulename": "setu.lid", "qualname": "IndicLID.model_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.classes", "modulename": "setu.lid", "qualname": "IndicLID.classes", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_lang_code_dict", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_lang_code_dict", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.IndicLID_lang_code_dict_reverse", "modulename": "setu.lid", "qualname": "IndicLID.IndicLID_lang_code_dict_reverse", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.IndicLID.pre_process", "modulename": "setu.lid", "qualname": "IndicLID.pre_process", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.char_percent_check", "modulename": "setu.lid", "qualname": "IndicLID.char_percent_check", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.native_inference", "modulename": "setu.lid", "qualname": "IndicLID.native_inference", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_list</span>, </span><span class=\"param\"><span class=\"n\">output_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.roman_inference", "modulename": "setu.lid", "qualname": "IndicLID.roman_inference", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_list</span>, </span><span class=\"param\"><span class=\"n\">output_dict</span>, </span><span class=\"param\"><span class=\"n\">batch_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.IndicBERT_roman_inference", "modulename": "setu.lid", "qualname": "IndicLID.IndicBERT_roman_inference", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">IndicLID_BERT_inputs</span>, </span><span class=\"param\"><span class=\"n\">output_dict</span>, </span><span class=\"param\"><span class=\"n\">batch_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.post_process", "modulename": "setu.lid", "qualname": "IndicLID.post_process", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.get_dataloaders", "modulename": "setu.lid", "qualname": "IndicLID.get_dataloaders", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">indices</span>, </span><span class=\"param\"><span class=\"n\">input_texts</span>, </span><span class=\"param\"><span class=\"n\">batch_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.predict", "modulename": "setu.lid", "qualname": "IndicLID.predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.IndicLID.batch_predict", "modulename": "setu.lid", "qualname": "IndicLID.batch_predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_list</span>, </span><span class=\"param\"><span class=\"n\">batch_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline", "modulename": "setu.lid", "qualname": "LIDPipeline", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "setu.lid.LIDPipeline.__init__", "modulename": "setu.lid", "qualname": "LIDPipeline.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indiclid_ftn_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/models/indiclid-ftn/model_baseline_roman.bin&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_ftr_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/models/indiclid-ftr/model_baseline_roman.bin&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_bert_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/models/indiclid-bert/basline_nn_simple.pt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">input_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">roman_lid_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.6</span>,</span><span class=\"param\">\t<span class=\"n\">nllb_model_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/models/lid218e.bin&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mapping_json_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/language_mapping.json&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">iso_mapping_json_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;data/lang_iso_mapping.json&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lid_probability_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.7</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "setu.lid.LIDPipeline.indiclid", "modulename": "setu.lid", "qualname": "LIDPipeline.indiclid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.LIDPipeline.cld3_detector", "modulename": "setu.lid", "qualname": "LIDPipeline.cld3_detector", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.LIDPipeline.nllb_detector", "modulename": "setu.lid", "qualname": "LIDPipeline.nllb_detector", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.LIDPipeline.lid_probability_threshold", "modulename": "setu.lid", "qualname": "LIDPipeline.lid_probability_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.lid.LIDPipeline.run_indiclid", "modulename": "setu.lid", "qualname": "LIDPipeline.run_indiclid", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">texts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline.run_cld3", "modulename": "setu.lid", "qualname": "LIDPipeline.run_cld3", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">texts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline.run_nllb", "modulename": "setu.lid", "qualname": "LIDPipeline.run_nllb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">texts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline.run_lid_single", "modulename": "setu.lid", "qualname": "LIDPipeline.run_lid_single", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">for_spark</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">lid_probability_threshold</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline.hard_vote", "modulename": "setu.lid", "qualname": "LIDPipeline.hard_vote", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_res</span>,</span><span class=\"param\">\t<span class=\"n\">cld3_res</span>,</span><span class=\"param\">\t<span class=\"n\">nllb_res</span>,</span><span class=\"param\">\t<span class=\"n\">lid_probability_threshold</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDPipeline.get_iso_code", "modulename": "setu.lid", "qualname": "LIDPipeline.get_iso_code", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lang</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.run_lid_on_each_partition_with_idx", "modulename": "setu.lid", "qualname": "run_lid_on_each_partition_with_idx", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">idx</span>,</span><span class=\"param\">\t<span class=\"n\">partition</span>,</span><span class=\"param\">\t<span class=\"n\">identifier_cols</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_ftn_path</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_ftr_path</span>,</span><span class=\"param\">\t<span class=\"n\">indiclid_bert_path</span>,</span><span class=\"param\">\t<span class=\"n\">input_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">roman_lid_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">nllb_model_path</span>,</span><span class=\"param\">\t<span class=\"n\">mapping_json_path</span>,</span><span class=\"param\">\t<span class=\"n\">iso_mapping_json_path</span>,</span><span class=\"param\">\t<span class=\"n\">lid_probability_threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.run_lid_spark_pipeline", "modulename": "setu.lid", "qualname": "run_lid_spark_pipeline", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">config</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">identifier_cols</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">lang_col_name</span>,</span><span class=\"param\">\t<span class=\"n\">iso_col_name</span>,</span><span class=\"param\">\t<span class=\"n\">data_root</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage", "modulename": "setu.lid", "qualname": "LIDStage", "kind": "class", "doc": "<p>SetuStage Base Class for the different stages in Setu Pipeline</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  The configuration file for the particular data type and language to be processed by the pipeline.</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.lid.LIDStage.__init__", "modulename": "setu.lid", "qualname": "LIDStage.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "setu.lid.LIDStage.add_cmdline_args", "modulename": "setu.lid", "qualname": "LIDStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular stage</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage.run_stage_parallelized", "modulename": "setu.lid", "qualname": "LIDStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Abstract method for running the stage in parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_lid_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage.run_data_parallelized", "modulename": "setu.lid", "qualname": "LIDStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Abstract method for running the stage in data parallel mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span>,</span><span class=\"param\">\t<span class=\"n\">additional_cols_to_use</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">doc_lid_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage.run_spark", "modulename": "setu.lid", "qualname": "LIDStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  The mode in which spark should execute, either data or stage parallel. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Throws an exception when unknown value is provided for parallel_mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable | Exception: Exception that indicates the user has provided an incorrect value for parallel_mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span>,</span><span class=\"param\">\t<span class=\"n\">lid_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_lid_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">lid_additional_cols</span>,</span><span class=\"param\">\t<span class=\"n\">lid_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">lid_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">lid_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">doc_lid_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage.run", "modulename": "setu.lid", "qualname": "LIDStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.lid.LIDStage.run_normal", "modulename": "setu.lid", "qualname": "LIDStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">lid_df_parquets_path</span>,</span><span class=\"param\">\t<span class=\"n\">is_lid_df_path_batched</span>,</span><span class=\"param\">\t<span class=\"n\">lid_additional_cols</span>,</span><span class=\"param\">\t<span class=\"n\">lid_samples_per_partition</span>,</span><span class=\"param\">\t<span class=\"n\">lid_verbose</span>,</span><span class=\"param\">\t<span class=\"n\">lid_run_mode</span>,</span><span class=\"param\">\t<span class=\"n\">doc_lid_output_path</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.main", "modulename": "setu.main", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.main.Setu", "modulename": "setu.main", "qualname": "Setu", "kind": "class", "doc": "<p>Main Setu Class which defines the pipeline object.</p>\n"}, {"fullname": "setu.main.Setu.__init__", "modulename": "setu.main", "qualname": "Setu.__init__", "kind": "function", "doc": "<p>__init__ Method that initializes the Setu Class object given the configuration path and data source type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config_file (str):</strong>  Path to the configuration file based on the language and data input type.</li>\n<li><strong>source_mode (str, optional):</strong>  Type of the data input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">source_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;crawl&#39;</span></span>)</span>"}, {"fullname": "setu.main.Setu.config", "modulename": "setu.main", "qualname": "Setu.config", "kind": "variable", "doc": "<p>Configuration Namespace object for the pipeline</p>\n"}, {"fullname": "setu.main.Setu.name", "modulename": "setu.main", "qualname": "Setu.name", "kind": "variable", "doc": "<p>Name of the pipeline</p>\n"}, {"fullname": "setu.main.Setu.te_component", "modulename": "setu.main", "qualname": "Setu.te_component", "kind": "variable", "doc": "<p>The TextExtraction Component of the pipeline.</p>\n"}, {"fullname": "setu.main.Setu.ca_component", "modulename": "setu.main", "qualname": "Setu.ca_component", "kind": "variable", "doc": "<p>The CleanAnalysis Component of the pipeline.</p>\n"}, {"fullname": "setu.main.Setu.fr_component", "modulename": "setu.main", "qualname": "Setu.fr_component", "kind": "variable", "doc": "<p>The FlagAndRemove Component of the pipeline</p>\n"}, {"fullname": "setu.main.Setu.components", "modulename": "setu.main", "qualname": "Setu.components", "kind": "variable", "doc": "<p>The dictionary mapping of the different components and their names.</p>\n"}, {"fullname": "setu.main.Setu.get_component_list", "modulename": "setu.main", "qualname": "Setu.get_component_list", "kind": "function", "doc": "<p>get_component_list Method that fetches a list of all the component names in the pipeline.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: A list of all the component names present as part of the pipeline.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.parse_args", "modulename": "setu.main", "qualname": "Setu.parse_args", "kind": "function", "doc": "<p>parse_args Method that parses the main and sub arguments required to execute the various stages and components.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Namespace: A Namespace object containing the required arguments for the pipeline.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.get_pipeline_name", "modulename": "setu.main", "qualname": "Setu.get_pipeline_name", "kind": "function", "doc": "<p>get_pipeline_name Method that returns the pipeline name.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Name of the pipeline.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.get_stage_component_mapping", "modulename": "setu.main", "qualname": "Setu.get_stage_component_mapping", "kind": "function", "doc": "<p>get_stage_component_mapping Method that returns the different stages mapped to their respective components.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: A dictionary containing the different components and their stages.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.load_config", "modulename": "setu.main", "qualname": "Setu.load_config", "kind": "function", "doc": "<p>load_config Method that loads the configuration variable from the config file path.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config_file (str):</strong>  Path to the configuration file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Namespace: Configuration Namespace object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.run_component", "modulename": "setu.main", "qualname": "Setu.run_component", "kind": "function", "doc": "<p>run_component Method that executes the particular component given the spark context object</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current spark session object.</li>\n<li><strong>component (str):</strong>  Name of the component to execute. Setu if execute whole pipeline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Returns the run function of the particular component</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">component</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.main.Setu.run", "modulename": "setu.main", "qualname": "Setu.run", "kind": "function", "doc": "<p>run Method that executes the pipeline.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current spark session object.</li>\n<li><strong>component (str):</strong>  Name of the component to execute. Setu if execute whole pipeline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Returns the run_component function of the particular component</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">component</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.run", "modulename": "setu.run", "kind": "module", "doc": "<p>The <a href=\"../../setu/run.py\">run.py</a>  is the script which is required to be submitted as part of the Spark Job. Make sure you provide the appropriate configuration file path, input data mode and to run on local or execute on GCP.</p>\n"}, {"fullname": "setu.text_extraction", "modulename": "setu.text_extraction", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.text_extraction.JSON2ParquetStage", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage", "kind": "class", "doc": "<p>JSON2ParquetStage The SetuStage Class extension for converting jsons to parquet files.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>SetuStage (class):</strong>  SetuStage class to inherit</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.__init__", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.__init__", "kind": "function", "doc": "<p>__init__ Initialize the JSON2ParquetStage with the configuration and mode provided</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  Configuration Namespace object for the particular language and data source.</li>\n<li><strong>mode (str, optional):</strong>  Mode that indicates the type of data source to process. Defaults to None.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  The mode provided does not correspond to any data source mode.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.add_cmdline_args", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Method that adds the JSON2ParquetStage arguments to the main setu parser.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  Main Setu parser</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ArgumentParser: Modified Setu parser object with stage arguments</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span></span><span class=\"return-annotation\">) -> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.run_stage_parallelized", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Method for executing the stage in stage parallel mode.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current Spark session object.</li>\n<li><strong>json_glob_path (str):</strong>  The input jsons path.</li>\n<li><strong>cols (list):</strong>  The list of columns to consider.</li>\n<li><strong>docs_per_partition (int):</strong>  The number of docs per spark partition.</li>\n<li><strong>doc_id_col (str):</strong>  The column name for the doc identifier.</li>\n<li><strong>is_multiline (bool):</strong>  Boolean value indicating if the json are multiline jsons.</li>\n<li><strong>output_path (str):</strong>  The output path to store the parquet files.</li>\n<li><strong>lang (str):</strong>  The language of the current data source</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">json_glob_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">is_multiline</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.schema_creator", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.schema_creator", "kind": "function", "doc": "<p>schema_creator Creats the schema for parquet conversion given a list of column names.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols (list):</strong>  List of input column names.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>StructType: Pyspark SQL StructType with Parquet Schema.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">StructType</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.convert_crawl_output", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.convert_crawl_output", "kind": "function", "doc": "<p>convert_crawl_output Method that converts the crawl jsons to parquets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current Spark session object.</li>\n<li><strong>json_list (list):</strong>  list of json paths.</li>\n<li><strong>docs_per_partition (int):</strong>  The number of docs per spark partition.</li>\n<li><strong>output_path (str):</strong>  The output path to save the parquets.</li>\n<li><strong>lang (str):</strong>  The language for the input data.</li>\n<li><strong>run_local (bool):</strong>  Boolean value indicating local or GCP execution.</li>\n<li><strong>is_multiline (_type_, optional):</strong>  Boolean value indicating if the json are multiline jsons. Defaults to None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">json_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">is_multiline</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.convert_ocr_output", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.convert_ocr_output", "kind": "function", "doc": "<p>convert_ocr_output Method that converts the crawl jsons to parquets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current Spark session object.</li>\n<li><strong>json_list (list):</strong>  list of json paths.</li>\n<li><strong>j2p_bucket (str):</strong>  GCP path for storing parquets</li>\n<li><strong>docs_per_partition (int):</strong>  The number of docs per spark partition.</li>\n<li><strong>output_path (str):</strong>  The output path to save the parquets.</li>\n<li><strong>lang (str):</strong>  The language for the input data.</li>\n<li><strong>run_local (bool):</strong>  Boolean value indicating local or GCP execution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">json_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_bucket</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lang</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.convert_asr_output", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.convert_asr_output", "kind": "function", "doc": "<p>convert_asr_output Method that converts the ASR output jsons to parquets.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>NotImplementedError:</strong>  Currently not supported.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.run_data_parallelized", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Method that triggers data parallel execution based on data source mode.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Returns the onvert Callable corresponding to the data source type.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.run_spark", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current spark session object.</li>\n<li><strong>json_glob_path (str):</strong>  The input jsons path.</li>\n<li><strong>j2p_cols (list):</strong>  The input data column list.</li>\n<li><strong>language (str):</strong>  The language of the current data source.</li>\n<li><strong>j2p_samples_per_partition (int):</strong>  The number of docs per partition</li>\n<li><strong>j2p_run_mode (str):</strong>  Either stage or data mode.</li>\n<li><strong>j2p_is_multiline (bool):</strong>  If the input jsons are multiline jsons.</li>\n<li><strong>j2p_parquet_output_path (str):</strong>  Output path to save parquets.</li>\n<li><strong>run_local (bool):</strong>  To execute in local or GCP</li>\n<li><strong>j2p_bucket (str):</strong>  The bucket to save outputs in GCP</li>\n<li><strong>j2p_bucket_prefix (str):</strong>  The bucket prefix for the GCP Bucket</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Incorrect Input Mode provided.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Returns run Callable based on stage or data mode.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">json_glob_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_samples_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_run_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_is_multiline</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_parquet_output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_bucket</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_bucket_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.run", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.JSON2ParquetStage.run_normal", "modulename": "setu.text_extraction", "qualname": "JSON2ParquetStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">json_glob_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_samples_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_run_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_parquet_output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_bucket</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">j2p_bucket_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage", "kind": "class", "doc": "<p>ExtractTextStage The SetuStage Class extension for extracting the text from the text column in the parquet files.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>SetuStage (class):</strong>  SetuStage class to inherit</li>\n</ul>\n", "bases": "base.SetuStage"}, {"fullname": "setu.text_extraction.ExtractTextStage.__init__", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.__init__", "kind": "function", "doc": "<p>__init__ Initialize the ExtractTextStage with the configuration provided</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>config (Namespace):</strong>  Configuration Namespace object for the particular language and data source.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span></span>)</span>"}, {"fullname": "setu.text_extraction.ExtractTextStage.add_cmdline_args", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Method that adds the ExtractTextStage arguments to the main setu parser.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  Main Setu parser</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>ArgumentParser: Modified Setu parser object with stage arguments</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parser</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage.run_stage_parallelized", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.run_stage_parallelized", "kind": "function", "doc": "<p>run_stage_parallelized Method for running the stage in parallel mode.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The input dataframe</li>\n<li><strong>docs_per_partition (int):</strong>  The number of documents per spark partition</li>\n<li><strong>output_path (str):</strong>  The output path to save the stage parquets.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>NotImplementedError:</strong>  Error indicating this method has not been implemented yet.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage.run_data_parallelized", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.run_data_parallelized", "kind": "function", "doc": "<p>run_data_parallelized Method for running the stage in data parallel mode.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The input dataframe</li>\n<li><strong>docs_per_partition (int):</strong>  The number of documents per spark partition</li>\n<li><strong>output_path (str):</strong>  The output path to save the stage parquets.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">docs_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage.run_spark", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.run_spark", "kind": "function", "doc": "<p>run_spark Method which triggers spark execution of the particular stage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spark (SparkSession):</strong>  The current Spark session object.</li>\n<li><strong>te_parquets_path (str):</strong>  The input parquets path.</li>\n<li><strong>te_samples_per_partition (int):</strong>  The number of samples per spark partition.</li>\n<li><strong>te_run_mode (str):</strong>  To run in data or stage mode.</li>\n<li><strong>te_output_path (str):</strong>  The output path to save the stage output parquets.</li>\n<li><strong>run_local (bool):</strong>  To run on local or GCP.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>Exception:</strong>  Exception indicating wrong mode provided.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: Either stage or data parallel run Callable is executed and returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>,</span><span class=\"param\">\t<span class=\"n\">te_parquets_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">te_samples_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">te_run_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">te_output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage.run", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.run", "kind": "function", "doc": "<p>run Method that triggers stage execution based on values of parallel_mode and if spark should be used.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parallel_mode (str, optional):</strong>  _description_. Defaults to \"stage\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Callable: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">SparkSession</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.ExtractTextStage.run_normal", "modulename": "setu.text_extraction", "qualname": "ExtractTextStage.run_normal", "kind": "function", "doc": "<p>run_normal Method for executing the stage in normal without Spark Utilization</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">te_parquets_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">te_samples_per_partition</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">te_run_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">te_output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">run_local</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.TextExtractionComponent", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent", "kind": "class", "doc": "<p>TextExtractionComponent The SetuComponent Class extension for converting jsons to parquet files and extracting the text from them.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>SetuComponent (class):</strong>  The SetuComponent to inherit.</li>\n</ul>\n", "bases": "base.SetuComponent"}, {"fullname": "setu.text_extraction.TextExtractionComponent.__init__", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">Namespace</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;crawl&#39;</span></span>)</span>"}, {"fullname": "setu.text_extraction.TextExtractionComponent.j2p_stage", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.j2p_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.text_extraction.TextExtractionComponent.te_stage", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.te_stage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.text_extraction.TextExtractionComponent.stages", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.stages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "setu.text_extraction.TextExtractionComponent.add_cmdline_args", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.add_cmdline_args", "kind": "function", "doc": "<p>add_cmdline_args Abstract Method for adding command line arguments for the particular component</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>parser (ArgumentParser):</strong>  The argument parser object to which the current stage arguments need to be added.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">parser</span><span class=\"p\">:</span> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span>,</span><span class=\"param\">\t<span class=\"n\">for_full_pipeline</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.TextExtractionComponent.get_stage_mapping", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.get_stage_mapping", "kind": "function", "doc": "<p>get_stage_mapping Method the provides the a dictionary mapping of the stage names as keys and their corresponding stage objects as values.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary containing the different stage names and objects as key/value pairs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.TextExtractionComponent.run_stage", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.run_stage", "kind": "function", "doc": "<p>run_stage Method the triggers the execution of a particular stage/omponent if the stage/component name is provided.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.text_extraction.TextExtractionComponent.run", "modulename": "setu.text_extraction", "qualname": "TextExtractionComponent.run", "kind": "function", "doc": "<p>run Method that triggers the execution of the component.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spark</span>, </span><span class=\"param\"><span class=\"n\">stage</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities", "modulename": "setu.utilities", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "setu.utilities.str2bool", "modulename": "setu.utilities", "qualname": "str2bool", "kind": "function", "doc": "<p>str2bool Returns the boolean equivalent given various string representations of the True/False values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (str):</strong>  A string that might represent a boolean value.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>argparse.ArgumentTypeError:</strong>  Error that mentions the provided value does not represent a boolean value.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool : Returns the bool equivalent of the provided value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.list_of_strings", "modulename": "setu.utilities", "qualname": "list_of_strings", "kind": "function", "doc": "<p>list_of_strings Generate the list of strings provided a single string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arg (str):</strong>  The string argument which needs to be split.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of strings of the string split using ',' delimitter.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.rename_partitioned_directories", "modulename": "setu.utilities", "qualname": "rename_partitioned_directories", "kind": "function", "doc": "<p>rename_partitioned_directories Function that renames the partitioned directiories.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>base_dir (str):</strong>  Base directory path</li>\n<li><strong>partition_column_name (str):</strong>  Column name based on which the partitions were produced.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">base_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">partition_column_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.ChunkHandler", "modulename": "setu.utilities", "qualname": "ChunkHandler", "kind": "class", "doc": "<p>ChunkHandler The Class representation for the a handler object that provides utilities that manipulates various chunks of text data.</p>\n"}, {"fullname": "setu.utilities.ChunkHandler.doc2lines", "modulename": "setu.utilities", "qualname": "ChunkHandler.doc2lines", "kind": "function", "doc": "<p>doc2lines Given a dataframe, Splits the various documents into multiple lines.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The dataframe object input.</li>\n<li><strong>text_column (str):</strong>  The column name for the text in the dataframe.</li>\n<li><strong>split_symbol (str):</strong>  The symbol on which splits need to be done.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">text_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">split_symbol</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.ChunkHandler.lines2doc", "modulename": "setu.utilities", "qualname": "ChunkHandler.lines2doc", "kind": "function", "doc": "<p>lines2doc Given a dataframe, Merges the various lines into documents.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df (DataFrame):</strong>  The dataframe object input.</li>\n<li><strong>text_column (str):</strong>  The column name for the text in the dataframe.</li>\n<li><strong>identifier_column (str):</strong>  The column based on which the lines need to be grouped into documents.</li>\n<li><strong>sort_column (str):</strong>  The column based on which the final dataframe needs to be sorted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">text_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">identifier_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">sort_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers", "kind": "class", "doc": "<p>SparkOptimizedHandlers The Class representation for the a handler object that provides utilities that manipulates the dataframe and provides with various statistics.</p>\n"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_num_lines", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_num_lines", "kind": "function", "doc": "<p>get_num_lines Method that returns the number of lines present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the number of lines.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_mean_line_length", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_mean_line_length", "kind": "function", "doc": "<p>get_mean_line_length Method that returns the mean line length of all the lines present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_len_col_ (str):</strong>  Column that represents the line length in a document.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the mean line length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_len_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_min_line_length", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_min_line_length", "kind": "function", "doc": "<p>get_min_line_length Method that returns the min line length of all the lines present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_len_col_ (str):</strong>  Column that represents the line length in a document.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the min line length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_len_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_max_line_length", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_max_line_length", "kind": "function", "doc": "<p>get_max_line_length Method that returns the max line length of all the lines present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_len_col_ (str):</strong>  Column name that contains the line length for the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the max line length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_len_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_nsfw_words_count", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_nsfw_words_count", "kind": "function", "doc": "<p>get_nsfw_words_count Method that returns the number of NSFW words present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_nsfw_count_col_ (str):</strong>  Column name that contains the nsfw word count for the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the total nsfw word count.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_nsfw_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_non_li_words_count", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_non_li_words_count", "kind": "function", "doc": "<p>get_non_li_words_count Method that returns the number of non latin-indic words in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_non_li_count_col_ (str):</strong>  Column name that contains the non-li word count for the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the total non-latin indic word count.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_non_li_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_bytes", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_bytes", "kind": "function", "doc": "<p>get_bytes Method that returns the total bytes that represent the data present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_bytes_col_ (str):</strong>  Column name that contains the total bytes for the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the total bytes of data present in the dataframe.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_bytes_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_words_count", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_words_count", "kind": "function", "doc": "<p>get_words_count Method that returns the total word count present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_words_count_col_ (str):</strong>  Column name that contains the word count of the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the total word count in the dataframe.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_words_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_char_count", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_char_count", "kind": "function", "doc": "<p>get_char_count Method that returns the total char count present in the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grouped_line_df (DataFrame):</strong>  Dataframe object containing the grouped lines.</li>\n<li><strong>line_char_count_col_ (str):</strong>  Column name that contains the char count of the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Value representing the total character count in the dataframe.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">grouped_line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">line_char_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.get_repeated_line_dist", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.get_repeated_line_dist", "kind": "function", "doc": "<p>get_repeated_line_dist Method that returns the distance between the closest repeated lines.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line_df (DataFrame):</strong>  Dataframe object containing the lines.</li>\n<li><strong>id_col (str):</strong>  The column based on which the dataframe needs to be grouped by.</li>\n<li><strong>text_col (str):</strong>  The column name for the text in the dataframe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: Returns the distance between repeated lines</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">text_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.run_analysis", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.run_analysis", "kind": "function", "doc": "<p>run_analysis Method that runs the analysis and aggregates the various stats for the dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line_df (DataFrame):</strong>  Dataframe object containing the lines.</li>\n<li><strong>doc_id_col (str):</strong>  The column based on which the dataframe needs to be grouped by.</li>\n<li><strong>line_nsfw_count_col_ (str):</strong>  Column name that contains the nsfw word count of the various document lines.</li>\n<li><strong>line_non_li_count_col_ (str):</strong>  Column name that contains the non latin-indic word count of the various document lines.</li>\n<li><strong>line_bytes_col_ (str):</strong>  Column name that contains the byte count of the various document lines.</li>\n<li><strong>line_words_count_col_ (str):</strong>  Column name that contains the word count of the various document lines.</li>\n<li><strong>line_char_count_col_ (str):</strong>  Column name that contains the character count of the various document lines.</li>\n<li><strong>only_base_stats (bool, optional):</strong>  If only return the basic statistic values. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: Returns the dataframe with computed statistic values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">line_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">doc_id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_nsfw_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_non_li_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_bytes_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_words_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">line_char_count_col_</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">only_base_stats</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "setu.utilities.SparkOptimizedHandlers.run_flagging", "modulename": "setu.utilities", "qualname": "SparkOptimizedHandlers.run_flagging", "kind": "function", "doc": "<p>run_flagging Method that executes the flagging stage based on computed document statistics.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc_df (DataFrame):</strong>  The dataframe object containing the various documents.</li>\n<li><strong>word_count_col (str):</strong>  Column name that contains the word count of the various document lines.</li>\n<li><strong>char_count_col (str):</strong>  Column name that contains the character word count of the various document lines.</li>\n<li><strong>nsfw_count_col (str):</strong>  Column name that contains the nsfw word count of the various document lines.</li>\n<li><strong>nsfw_threshold (float):</strong>  Threshold value for number of NSFW words acceptable.</li>\n<li><strong>non_li_count_col (str):</strong>  Column name that contains the non latin-indic word count of the various document lines.</li>\n<li><strong>non_li_threshold (float):</strong>  Threshold value for number of non latin-indic words.</li>\n<li><strong>min_line_count (int):</strong>  Threshold value for minimum number of lines to constitute a document.</li>\n<li><strong>line_count_col (str):</strong>  Column name that contains the line count of the various documents.</li>\n<li><strong>min_mean_line_len (int):</strong>  Threshold value for the mean line length.</li>\n<li><strong>mean_line_len_col (str):</strong>  Column name that contains the mean line length of the various document lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">doc_df</span><span class=\"p\">:</span> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">word_count_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">char_count_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_count_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">nsfw_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">non_li_count_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">non_li_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">min_line_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">line_count_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">min_mean_line_len</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">mean_line_len_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pyspark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();